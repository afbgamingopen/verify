<script setup>
</script>

<template>
  <div class="content">
    <div>
        <h2>Random Number Generation</h2>
        <p>For each verifiable bet, a client
            seed, a server seed, a nonce and a cursor are used as the input parameters for the <a
                href="https://en.wikipedia.org/wiki/Random_number_generation" rel="external noreferrer noopener"
                target="_blank" weight="semibold"><span>random number generation</span></a>
            function. This function utilises the cryptographic hash function 
            <a
                href="https://en.wikipedia.org/wiki/HMAC" rel="external noreferrer noopener" target="_blank"
                weight="semibold"> <span >HMAC_SHA256</span></a>
            to generate bytes which are then used as the foundation for how we generate provably fair random
            outcomes on our platform.</p>
        <p>
        <pre>
            <code>
// Random number generation based on following inputs: serverSeed, clientSeed, nonce and cursor
function byteGenerator({ serverSeed, clientSeed, nonce, table, cursor }) {
    // Setup curser variables
    let currentRound = Math.floor(cursor / 32);
    let currentRoundCursor = cursor;
    currentRoundCursor -= currentRound * 32;

    // Generate outputs until cursor requirement fullfilled
    while (true) {
        // HMAC function used to output provided inputs into bytes
        const hmac = createHmac('sha256', serverSeed);
        hmac.update(`${clientSeed}:${nonce}:${table}:${currentRound}`);
        const buffer = hmac.digest();

        // Update curser for next iteration of loop
        while (currentRoundCursor &lt; 32) {
            yield Number(buffer[currentRoundCursor]);
            currentRoundCursor += 1;
        }
        currentRoundCursor = 0;
        currentRound += 1;
    }
}
            </code>
        </pre>
        </p>
        <h2>Server Seed</h2>
        <p>The server seed is generated by our system as a random 64-character hex string. You are then
            provided with an encrypted hash of that generated server seed before you place any bets. The reason we
            provide you with the encrypted form of the
            server seed is to ensure that the un-hashed server seed cannot be changed by the casino
            operator, and that the player cannot calculate
            the results beforehand.</p>
        <p>To reveal the server seed from its hashed version, the seed must be rotated by the player, which
            triggers the replacement with a newly generated one.</p>
        <p>From this point you are able to verify that the hashed server seed matches that of the un-hashed
            server seed. This process can be verified via our un-hashed server seed function found in the
            menu above.</p>
        <h2>Client Seed</h2>
        <p>The client seed belongs to the player and is
            used to ensure the
            player also has influence on the randomness
            of the outcomes generated. Without this component of the algorithm, the server seed alone would have
            complete leverage
            over the outcome of each bet.</p>
        <p>All players are free to edit and change
            their client seed regularly to create a new chain of random upcoming outcomes. This ensures the player has
            absolute control over the generation of the result, similar to cutting the deck
            at a brick and mortar casino.</p>
        <p>During registration, a client seed is created for you by your browser, to ensure your initial
            experience with the site goes uninterrupted. Whilst this randomly generated client seed is
            considered suitable, we highly recommend that you choose your own, so that your influence is
            included in the randomness.</p>
        <p>You can do this via the fairness modal.</p>
        <h2>Nonce</h2>
        <p>The nonce is simply a number that increments as every new bet is made. Due to the nature of the
            SHA256 cryptographic function, this
            creates a completely new result each time, without having to generate a new client seed and
            server seed.</p>
        <p>The implementation of nonce, ensures we remain committed to your client seed and server seed
            pair, whilst generating new results for each bet placed.</p>
        <h2>Table</h2>
        <p>Table is the game table selected by the player, one game can have multiple tables, namely Junior, Intermediate, Senior, etc.</p>
        <h2>Cursor (Incremental Number)</h2>
        <p>We use 4 bytes of data to generate a single game result, and because SHA256 is limited to 32
            bytes, we utilise this implementation of a cursor to give us the ability to create more game
            events without having to modify our provable fair algorithm.</p>
        <p>The cursor is only iterated over when the game being played requires the generation of more than
            8 (32 bytes / 4 bytes) possible outcomes. For example: when we need to use more than 8 cards in
            a game of blackjack.</p>
        <p>The cursor starts as 0 and gets increased by 1 every time the 32 bytes are returned by the
            HMAC_SHA256 function. If we donâ€™t require more than 8 random numbers to be generated for the
            game events, then the curser does not increment as there is no need to generate any additional
            possible game outcomes.</p>
        <h2>Bytes to Floats</h2>
        <p>The output of the Random Number Generator (byteGenerator) function is a hexadecimal 32-byte
            hash. As explained under the cursor implementation, we use 4 bytes of data to generate a single
            game result. Each set of 4 bytes are used to generate floats between 0 and 1 (4 bytes are used
            instead of one to ensure a higher level of precision when generating the float.) It is with
            these generated floats that we derive the formal output of the provable fair algorithm before it
            is translated into game events.</p>
        <p>
        <pre>      
            <code>
// Convert the hash output from the rng byteGenerator to floats
function generateFloats ({ serverSeed, clientSeed, nonce, table, cursor, count }) {
    // Random number generator function
    const rng = byteGenerator({ serverSeed, clientSeed, nonce, table, cursor });
    // Declare bytes as empty array
    const bytes = [];

    // Populate bytes array with sets of 4 from RNG output
    while (bytes.length &lt; count * 4) {
        bytes.push(rng.next().value);
    }

    // Return bytes as floats using lodash reduce function
    return _.chunk(bytes, 4).map(bytesChunk =&gt;
    bytesChunk.reduce((result, value, i) =&gt; {
                const divider = 256 ** (i + 1);
                const partialResult = value / divider;
                return result + partialResult;
            }, 0)
        );
};
            </code>
        </pre>
        </p>

        <h2>Dice</h2>
        <p>In our version of dice, we cover a possible roll spread of 00.00 to 100.00, which has a range of
            10,001 possible outcomes. The game event translation is done by multiplying the float by number
            of possible outcomes and then dividing by 100 so that the resulting number fits the constraints
            of our stated dice range.
        </p>
        <p>
            <pre>
                <code>
// Game event translation
const roll = (float * 10001) / 100;
                </code>
            </pre>
        </p>
    </div>
</div>

</template>

<style scoped>

</style>
