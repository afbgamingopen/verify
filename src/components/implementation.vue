<script setup>
</script>

<template>
    <div class="content">
        <el-collapse v-model="activeNames" accordion>
          <el-collapse-item title="Random Number Generation" name="1">
            <div>
                <p>For each verifiable bet, a client
                    seed, a server seed, a nonce and a cursor are used as the input parameters for the <a
                        href="https://en.wikipedia.org/wiki/Random_number_generation" rel="external noreferrer noopener"
                        target="_blank" weight="semibold"><span>random number generation</span></a>
                    function. This function utilises the cryptographic hash function 
                    <a
                        href="https://en.wikipedia.org/wiki/HMAC" rel="external noreferrer noopener" target="_blank"
                        weight="semibold"> <span >HMAC_SHA256</span></a>
                    to generate bytes which are then used as the foundation for how we generate provably fair random
                    outcomes on our platform.</p>
                <p>
                <pre>
                    <code>
    // Random number generation based on following inputs: serverSeed, clientSeed, nonce and cursor
    function byteGenerator({ serverSeed, clientSeed, nonce, cursor }) {
        // Setup curser variables
        let currentRound = Math.floor(cursor / 32);
        let currentRoundCursor = cursor;
        currentRoundCursor -= currentRound * 32;
    
        // Generate outputs until cursor requirement fullfilled
        while (true) {
            // HMAC function used to output provided inputs into bytes
            const hmac = createHmac('sha256', serverSeed);
            hmac.update(`${clientSeed}:${nonce}:${currentRound}`);
            const buffer = hmac.digest();
    
            // Update curser for next iteration of loop
            while (currentRoundCursor &lt; 32) {
                yield Number(buffer[currentRoundCursor]);
                currentRoundCursor += 1;
            }
            currentRoundCursor = 0;
            currentRound += 1;
        }
    }
                    </code>
                </pre>
                </p>
            </div>
            <div>
              Consistent within interface: all elements should be consistent, such
              as: design style, icons and texts, position of elements, etc.
            </div>
          </el-collapse-item>
          <el-collapse-item title="Server Seed" name="2">
            <div>
                <p>The server seed is generated by our system as a random 64-character hex string. You are then
                    provided with an encrypted hash of that generated server seed before you place any bets. The reason we
                    provide you with the encrypted form of the
                    server seed is to ensure that the un-hashed server seed cannot be changed by the casino
                    operator, and that the player cannot calculate
                    the results beforehand.</p>
                <p>To reveal the server seed from its hashed version, the seed must be rotated by the player, which
                    triggers the replacement with a newly generated one.</p>
                <p>From this point you are able to verify that the hashed server seed matches that of the un-hashed
                    server seed. This process can be verified via our un-hashed server seed function found in the
                    menu above.</p>
            </div>
          </el-collapse-item>
          <el-collapse-item title="Client Seed" name="3">
            <div>
                <p>The client seed belongs to the player and is
                    used to ensure the
                    player also has influence on the randomness
                    of the outcomes generated. Without this component of the algorithm, the server seed alone would have
                    complete leverage
                    over the outcome of each bet.</p>
                <p>All players are free to edit and change
                    their client seed regularly to create a new chain of random upcoming outcomes. This ensures the player has
                    absolute control over the generation of the result, similar to cutting the deck
                    at a brick and mortar casino.</p>
                <p>During registration, a client seed is created for you by your browser, to ensure your initial
                    experience with the site goes uninterrupted. Whilst this randomly generated client seed is
                    considered suitable, we highly recommend that you choose your own, so that your influence is
                    included in the randomness.</p>
                <p>You can do this via the fairness modal.</p>
            </div>
          </el-collapse-item>
          <el-collapse-item title="Nonce" name="4">
            <div>
                <p>The nonce is simply a number that increments as every new bet is made. Due to the nature of the
                    SHA256 cryptographic function, this
                    creates a completely new result each time, without having to generate a new client seed and
                    server seed.</p>
                <p>The implementation of nonce, ensures we remain committed to your client seed and server seed
                    pair, whilst generating new results for each bet placed.</p>
            </div>
          </el-collapse-item>
          <el-collapse-item title="Cursor (Incremental Number)" name="5">
            <div>
                <p>We use 4 bytes of data to generate a single game result, and because SHA256 is limited to 32
                    bytes, we utilise this implementation of a cursor to give us the ability to create more game
                    events without having to modify our provable fair algorithm.</p>
                <p>The cursor is only iterated over when the game being played requires the generation of more than
                    8 (32 bytes / 4 bytes) possible outcomes. For example: when we need to use more than 8 cards in
                    a game of blackjack.</p>
                <p>The cursor starts as 0 and gets increased by 1 every time the 32 bytes are returned by the
                    HMAC_SHA256 function. If we don’t require more than 8 random numbers to be generated for the
                    game events, then the curser does not increment as there is no need to generate any additional
                    possible game outcomes.</p>
            </div>
          </el-collapse-item>
          <el-collapse-item title="Bytes to Floats" name="6">
            <div>
                <p>The output of the Random Number Generator (byteGenerator) function is a hexadecimal 32-byte
                    hash. As explained under the cursor implementation, we use 4 bytes of data to generate a single
                    game result. Each set of 4 bytes are used to generate floats between 0 and 1 (4 bytes are used
                    instead of one to ensure a higher level of precision when generating the float.) It is with
                    these generated floats that we derive the formal output of the provable fair algorithm before it
                    is translated into game events.</p>
                <p>
                <pre>      
                    <code>
    // Convert the hash output from the rng byteGenerator to floats
    function generateFloats ({ serverSeed, clientSeed, nonce, cursor, count }) {
        // Random number generator function
        const rng = byteGenerator({ serverSeed, clientSeed, nonce, cursor });
        // Declare bytes as empty array
        const bytes = [];
    
        // Populate bytes array with sets of 4 from RNG output
        while (bytes.length &lt; count * 4) {
            bytes.push(rng.next().value);
        }
    
        // Return bytes as floats using lodash reduce function
        return _.chunk(bytes, 4).map(bytesChunk =&gt;
        bytesChunk.reduce((result, value, i) =&gt; {
                    const divider = 256 ** (i + 1);
                    const partialResult = value / divider;
                    return result + partialResult;
                }, 0)
            );
    };
                    </code>
                </pre>
                </p>
            </div>
          </el-collapse-item>
          <el-collapse-item title="Single Baccarat" name="7">
            <div>
                <p>In a standard deck of cards, there are 52 unique possible outcomes. When it comes to playing
                    Baccarat on our platform, we utilise an unlimited amount of decks when
                    generating the game event, and therefore each turn of a card always has the same probability. To
                    calculate this, we multiply each randomly generated float by 52, and then translate that result
                    into a particular card, based on the following index:</p>
                <p>
                    <pre>
                        <code>
    // Index of 0 to 51 : ♦2 to ♣A
    const CARDS = [ 
        ♦2, ♥2, ♠2, ♣2, ♦3, ♥3, ♠3, ♣3, ♦4, ♥4,  
        ♠4, ♣4, ♦5, ♥5, ♠5, ♣5, ♦6, ♥6, ♠6, ♣6, 
        ♦7, ♥7, ♠7, ♣7, ♦8, ♥8, ♠8, ♣8, ♦9, ♥9, 
        ♠9, ♣9, ♦10, ♥10, ♠10, ♣10, ♦J, ♥J, ♠J, 
        ♣J, ♦Q, ♥Q, ♠Q, ♣Q, ♦K, ♥K, ♠K, ♣K, ♦A, 
        ♥A, ♠A, ♣A 
    ]; 
    // Game event translation
    const card = CARDS[Math.floor(float * 52)];</code>
                    </pre>
                </p>
                <p>When it comes to <strong>Baccarat</strong> we only ever need 6 game events
                    generated to cover the most amount of playable cards possible.</p>
            </div>
          </el-collapse-item>
          <el-collapse-item title="Classic Baccarat" name="8">
            <div>
                <p>All cards in the game are encryptedusing globally recognized blockchain encryption algorithm technology. Players can check the serial number of each card when every boots change. The “private key” (card value) will be displayed after card opened, and players can use the default tool to verify if the private key matches the serial number which shown in the beginning. Thus the fairness can be guaranteed by the algorithm.</p>
                <p>The game uses 8 decks of playing cards (52 cards for each deck), 416 cards in total. The gameplay and odds are same as general Baccarat, please go to the general Baccarat game rules page to check.</p>
                <p>Game Flow</p>
                <p><img src="@/assets/baccarat-1.png"></p>
                <p>About Index, Private key & Serial number</p>
                <p>Every card has an index, private key and serial number.</p>
                <p><img src="@/assets/baccarat-2.png"></p>
                <p><img src="@/assets/baccarat-3.png"></p>
                <p><img src="@/assets/baccarat-4.png"></p>
    
            </div>
          </el-collapse-item>
          <el-collapse-item title="Dice" name="9">
            <div>
                <p>In our version of dice, we cover a possible roll spread of 00.00 to 100.00, which has a range of
                    10,001 possible outcomes. The game event translation is done by multiplying the float by number
                    of possible outcomes and then dividing by 100 so that the resulting number fits the constraints
                    of our stated dice range.
                </p>
                <p>
                    <pre>
                        <code>
    // Game event translation
    const roll = (float * 10001) / 100;
                        </code>
                    </pre>
                </p>
            </div>
          </el-collapse-item>
          <el-collapse-item title="Plinko" name="10">
            <div>
                <p>For any game of Plinko, the generated outcome is based on the path of the falling ball. The game event determines the direction of the falling ball for each level in the falling process. Players can choose between 8 and 16 pins of play, which determines the number of game events required to generate a complete path from top to bottom. Since there are only two possible directions (left or right) the translation is done by multiplying each float by 2, which maps to the following index:</p>
                <p>
                    <pre>
                        <code>
    // Index of 0 to 1 : left to right
    const DIRECTIONS = [ left, right ];

    // Game event translation
    const direction = CARDS[Math.floor(float * 2)];</code>
                    </pre>
                </p>
        
            </div>
          </el-collapse-item>
          <el-collapse-item title="Crash" name="11">
            <div>
                <p>The seed hash of each round will be announced on the game interface before placing bets.</p>
                <p>
                    <pre>
                        <code>
    // Game event translation
    const result = 4294967296 / ( float + 1) * (1 - 0.03) 
                        </code>
                    </pre>
                </p>
            </div>
          </el-collapse-item>
        </el-collapse>
    </div>
</template>

<style scoped>
.el-collapse {
    border-top: none;
}

</style>
